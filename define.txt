预处理语句#define   往后的所有语句中的宏都会被替换 直到#undef
无参数宏 直接替换
带参数宏 参数和宏一起替换

预处理从最外层，替代，执行宏语句，执行完后,进行分段解析然后替换每段中存在的宏。没有找到宏则处理完毕。   
也可以理解为带参宏定义，在语句中第一次对它解析不会将参数列表中的宏进行替换，之后的每次解析都会先将参数列表中的宏进行替换，然后执行带参数宏
#和## 都是操作符，为预处理运算符，带参数宏用实参将形参代替后，先执行预处理语句，运算符优先作用
# 将连接后的形参解释为字符串，加入到宏语句字符串中 
#define   a（f）   #f

## 是一种分隔连接方式，先将前后字段进行分隔，然后强制连接
其中，分隔的作用就类似于空格。预处理器一般把空格解释成分段标志。类似于声明变量 char a时之间的空格。对于带参宏定义，每一段相同的会和前面的参数列表进行比较，相同的进行替换，但是
替换后段之间会保留空格，如果我们不希望出现这些空格，就可以添加##代替这些空格，将段与段进行连接
#define A1(name, type)  type name_##type##_type 或

#define A2(name, type)  type name##_##type##_type

A1(a1, int);  /* 等价于: int name_int_type; */

A2(a1, int);  /* 等价于: int a1_int_type;   */

需要注意的是，()并非预处理运算符，只有在进行替换完成后，才会对这替换后的结果进行解析。如果为带参宏函数，则最外层的()里的内容都会被识别为参数。

其实不难发现，对于编译器而言，运算符号，包括空格，都具有先将前后分段的作用，只有分段后，整段和变量或者宏定义名称相同，才会进行对应

